#!/usr/bin/env python3

###############################################################################
#
# Copyright (C) 2015 Aleksandrina Nikolova <aayla.secura.1138@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
#
# A control file for the LFI-3751 temperature controller
# Requires seriald, regex and matplotlib

import os
import random
import regex
import signal
import socket
import sys
from matplotlib import animation, pyplot, ticker
from time import time, sleep, strftime
from optparse import OptionParser, make_option
from seriald import SerialDaemon
from serial import Serial, EIGHTBITS, PARITY_NONE, STOPBITS_ONE

###############################################################################
################################ DAEMON RELATED ###############################
###############################################################################

def get_pid(pidfile_path):
    if not os.path.exists(pidfile_path):
        return None
    
    with open(pidfile_path, 'r') as pidfile:
        return int(pidfile.readline().strip())
    
def start(*args):
    daemon = SerialDaemon(
        name = exec_name,
        config_file_path = config_file,
        pidfile_path = pidfile,
        socket_port = socket_port,
        data_encoding = data_encoding,
        port = serial_port,
        baudrate = baudrate,
        bytesize = bytesize,
        parity = parity,
        stopbits = stopbits,
        xonxoff = xonxoff,
        timeout = serial_timeout
    )
    daemon.start()
    
def stop(*args):
    pid = get_pid(pidfile)
    if pid is None:
        return
    
    try:
        os.kill(pid, signal.SIGTERM)
    except OSError:
        print('Could not kill process {}'.format(pid), file = sys.stderr)

def restart(*args):
    stop()
    sleep(1)	# wait for pidfile lock
    start()

def reload_config(*args):
    pid = get_pid(pidfile)
    if pid is None:
        return
    
    try:
        os.kill(pid, signal.SIGHUP)
    except OSError:
        print('Could not send SIGHUP to process {}'.format(pid),
              file = sys.stderr)

# must return 0 on success
def interact(*args):
    prompt = """Enter "command value [address]".
    Values are optional, their presence indicates a write command.
    Address is optional, defaults to 1.
    Enter to quit.
    """

    soc = connect_to_socket()
    try:
        while True:
            status, cmd, val, addr = process_input(input(prompt).split(' '))[0:4]
            if status == 0:
                if cmd is not None:
                    send_cmd(cmd, val, addr, soc)
                else:
                    break
    except KeyboardInterrupt:
        pass

    soc.close()
    return 0

# must return 0 on success
def plot_realtime(user_input):
    # user_input[0] will be 'plot', discard it
    status, cmd, val, addr, interval, \
        log_file_path, log_dir = process_input(user_input[1:])
    
    if status != 0:
        return status

    if log_file_path is None:
        log_file_path = os.path.join(log_dir, '{name}_{date}.log'.format(
            name = exec_name,
            date = strftime('%Y-%m-%d_%H-%M-%S')))

    soc = connect_to_socket()
        
    def data_get():
        start_time = time()
        cur_time = 0
        
        with open(log_file_path, 'a') as log_file:
            while True:
                status, data = send_cmd(cmd, val, addr, soc, verbose = False)
                sleep(interval)
                
                if status == 1:
                    # argument processing did not succeed, abort
                    break
                if status == 2:
                    # reading reply from device did not succeed, ignore
                    continue

                data = float(data)
                log_file.write('{time!s}\t{data!s}\n'.format(
                    time = cur_time,
                    data = data))
                if cur_time == 0:
                    axes.set_ylim(data - 0.01, data + 0.01)
                    
                yield cur_time, data
                cur_time = time() - start_time
                
            
    def run(new_data):
        x, y = new_data
        xdata.append(x)
        ydata.append(y)
        xmin, xmax = axes.get_xlim()
        ymin, ymax = axes.get_ylim()

        if x > xmax:
            axes.set_xlim(xmin, x)
        if y > ymax:
            axes.set_ylim(ymin, y)
        elif y < ymin:
            axes.set_ylim(y, ymax)
            
        curve.set_data(xdata, ydata)
        axes.figure.canvas.draw()

        return curve,

    fig, axes = pyplot.subplots()
    curve, = axes.plot([], [], lw = 2)
    y_formatter = ticker.ScalarFormatter(useOffset = False)
    axes.yaxis.set_major_formatter(y_formatter)
    # y limit is set in data_gen
    axes.set_xlim(0, 1)
    axes.set_title(cmd)
    axes.set_xlabel('Time / s')
    axes.set_ylabel('')
    axes.grid()
    xdata, ydata = [], []

    anim = animation.FuncAnimation(
        fig,
        run,
        frames = data_get,
        blit = False,
        interval = 10,
        repeat = False
        )
    pyplot.subplots_adjust(
        left = 0.09,
        bottom = 0.09,
        right = 0.97,
        top = 0.95,
        wspace = 0,
        hspace = 0
    )
    try:
        pyplot.show()
    except KeyboardInterrupt:
        pass

    soc.close()
    return 0

# must return 0 on success
def onetime_action(user_input):
    status, cmd, val, addr = process_input(user_input)[0:4]
    if status == 0:
        status = send_cmd(cmd, val, addr)[0]
    return status
    
# must return 0 on success
def send_cmd(cmd, val, addr, soc = None, verbose = True):
    status, cmd_str = generate_cmd(cmd, val, addr)
    data = None
    if status == 0:
        if soc is None:
            # one-time command mode
            soc = connect_to_socket()
            soc_close = True
        else:
            # continuous command mode
            soc_close = False

        # the device is to be halted (does not send a reply)
        if cmd == 'HALT':
            # 1st byte is 0 => do not read reply from device
            soc.sendall(bytes('0{}'.format(cmd_str), data_encoding))
        else:
            # read reply_length bytes from device
            soc.sendall(bytes('2{length:0>2X}{cmd}'.format(
                length = reply_length,
                cmd = cmd_str), data_encoding))
            try:
                reply = soc.recv(1024).decode(data_encoding)
            except socket.timeout:
                status = 2
            else:
                data = reply[first_data_char - 1 : last_data_char]
                if verbose:
                    print('Device replied with: {data}'.format(
                        data = data))
                    if 'info' in cmds[cmd]['read']:
                        print(cmds[cmd]['read']['info'])
                    
        if soc_close:
            soc.close()

    return status, data

def connect_to_socket():
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        soc.connect((socket_host, socket_port))
    except ConnectionRefusedError:
        print('Connection refused. Did you forget to start the daemon?',
              file = sys.stderr)
        sys.exit(2)
        
    soc.setblocking(0)
    soc.settimeout(socket_timeout)
    return soc

###############################################################################
################################ SERIAL RELATED ###############################
###############################################################################

def generate_fcs(cmd):
    fcs = 0
    for char in cmd:
        fcs = fcs^ord(char)
    return fcs

# must return 0 on success
def generate_cmd(cmd, val, addr):
    if val:
        cmd_type = 'write'
    else:
        cmd_type = 'read'
        
    cmd_code = cmds[cmd]['code']
    cmd_vals = cmds[cmd][cmd_type]
    
    # format must be defined if cmd_type is allowed for this command
    if 'format' not in cmd_vals:
        print(('{type} is not a valid operation for command ' +
               '{cmd}').format(cmd = cmd, type = cmd_type),
              file = sys.stderr)
        return 1, None

    if cmd_type == 'write':
        # it is a write command
        
        cmd_type = write_char
        for alias in cmd_vals['alias'].keys() if 'alias' in cmd_vals else []:
            # check if it is an alias
            if val == alias:
                val = cmd_vals['alias'][alias]
                break
            
        else:
            # else, first check if it is in the right format
            val_format = cmd_vals['format']
            
            if val_format == '+DDD.DDD':
                # value should be numeric
                # accept any valid number and convert it to the right format
                regex_pat = regex.compile('[+-]?[0-9]*(\.[0-9]*)?')
                if regex_pat.fullmatch(val) is None:
                    print(('{val} is neither a known alias nor in the ' +
                           'allowed format for command {cmd}').format(
                               cmd = cmd,
                               val = val),
                          file = sys.stderr)
                    return 1, None
                    
                val = '{sign}{val:0>7.3f}'.format(
                    sign = ('+' if val[0].isdigit() or \
                            val[0] == '.' else val[0]),
                    val = abs(float(val)))
            else:
                val_format = val_format.replace('+', '\+')
                val_format = val_format.replace('D', '[0-9]')
                val_format = val_format.replace('A', '[a-zA-Z0-9_-]')
                regex_pat = regex.compile(val_format, regex.I)
                
                if regex_pat.fullmatch(val) is None:
                    print(('{val} is neither a known alias nor in the ' +
                           'allowed format for command {cmd}').format(
                               cmd = cmd,
                               val = val),
                          file = sys.stderr)
                    return 1, None
        
            # then check if it is in the allowed range
            if 'range' in cmd_vals:
                low_limit = float(cmd_vals['range'].split(' ')[0])
                high_limit = float(cmd_vals['range'].split(' ')[1])
                
                if not low_limit <= float(val) <= high_limit:
                    print(('{val} is not within the allowed numerical range ' +
                           'for command {cmd}').format(cmd = cmd, val = val),
                          file = sys.stderr)
                    return 1, None

    else:
        # it is a read command
        
        cmd_type = read_char
        val = cmd_vals['format'].replace('D', '0').replace('A', '0')

    # command to the device must be in the following format
    cmd = '{}{}{}{}{}{}'.format(
        cmd_char,
        unit_type,
        addr,
        cmd_type,
        cmd_code,
        val
    )
    # append the FCS
    cmd = '{cmd}{fcs:0>2X}'.format(cmd = cmd, fcs = generate_fcs(cmd))
    return 0, cmd

###############################################################################
##################################### MISC ####################################
###############################################################################

def process_input(user_input):
    opts, args = opt_parser.parse_args(user_input)

    if len(args) == 0:
        return 0, None, None, None, None, None, None

    cmd = args[0].upper()
    address = opts.address
    interval = opts.interval
    log_file = opts.log_file
    log_dir = opts.log_dir
    
    if cmd == 'HALT' or cmd == 'LOCAL':
        # user does not provide value for this operation
        # but operation is still 'write'
        args.insert(1, '+000.000')

    if not 1 <= len(args) <= 2:
        usage()

    if not min_unit_address <= address <= max_unit_address:
        print(('Unit address must be between {min} and {max}! ' +
               'Aborting.').format(min = min_unit_address,
                                   max = max_unit_address),
              file = sys.stderr)
        return 1, None, None, None, None, None, None
    address = '{!s:0>2}'.format(address)

    if interval < 0:
        print('Check interval cannot be negative!', file = sys.stderr)
        return 1, None, None, None, None, None, None

    if log_dir != '':
        if not os.path.isdir(log_dir):
            os.mkdir(log_dir, mode = 0o755)
            
    if len(args) == 2:
        val = args[1]
    else:
        val = ''

    return 0, cmd, val, address, interval, log_file, log_dir

def usage():
    process_input(['--help'])
    sys.exit(2)
    
###############################################################################
#################################### GLOBAL ###################################
###############################################################################

exec_name = os.path.basename(__file__)
allowed_actions = {
    'start': {
        'usage': 'start',
        'callable': start,
        'num_args': [ 0 ]
    },
    'stop': {
        'usage': 'stop',
        'callable': stop,
        'num_args': [ 0 ]
    },
    'restart': {
        'usage': 'restart',
        'callable': restart,
        'num_args': [ 0 ]
    },
    'reload': {
        'usage': 'reload',
        'callable': reload_config,
        'num_args': [ 0 ]
    },
    'interact': {
        'usage': 'interact',
        'callable': interact,
        'num_args': [ 0 ]
    },
    'plot': {
        'usage': 'plot <command> [--address] [--interval] [--log-file|--log-dir]',
        'callable': plot_realtime,
        'num_args': range(1,5)
    },
    'single': {
        'usage': '<command> [<value>] [--address]',
        'callable': onetime_action,
        'num_args': range(0,3)
    }
}

pidfile = '/var/run/{name}.pid'.format(name = exec_name)
config_file = None
socket_host = 'localhost'       # host to connect to
socket_port = 57001             # port to request the daemon to listen on
socket_timeout = 1              # timeout in seconds for socket.recv()
data_encoding = 'utf-8'	        # encoding of data transmitted over socket
default_plot_interval = 1       # seconds between data acquisition

# required configuration of serial port
serial_port = '/dev/ttyS0'
baudrate = 19200
bytesize = EIGHTBITS
parity = PARITY_NONE
stopbits = STOPBITS_ONE
xonxoff =  True
serial_timeout = 0.5

unit_type = '1'	                # must be 1 - signifies temperature controller
default_unit_address = 1        # default unit address
min_unit_address = 1
max_unit_address = 2
cmd_char = '!'	                # commands to the device must start with !
cmd_length = 15	                # and must be 15 bytes long excluding FCS
reply_length = 21               # device sends 21 bytes of data
first_data_char = 10            # bytes 10 to 17 are the data field in the reply
last_data_char = 17
read_char = '1'	                # 1 for read commands, 2 for write commands
write_char = '2'
temp_lims = '-199.900 +199.900'	# temperature limits
res_lims = '+000.000 +499.900'	# resistance limits
cmds = {
    'ACT_T': {
	'code': '01',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'ACT_R': {
	'code': '02',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'SET_T': {
	'code': '03',
        'read': {
	    'format': '+DDD.DDD'
        },
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'SET_R': {
	'code': '04',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'TE_I': {
	'code': '05',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'TE_V': {
	'code': '06',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'LIM_I_POS': {
	'code': '07',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +005.000'
	}
    },
    'LIM_I_NEG': {
	'code': '08',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '-005.000 +000.000'
	}
    },
    'AUX_T': {
	'code': '09',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'P': {
	'code': '10',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +100.000',
            'alias': {
                'AUTO_S': '-002.000',
                'AUTO_D': '-001.000'
            }
	}
    },
    'I': {
	'code': '11',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.400 +010.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'D': {
	'code': '12',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+001.000 +100.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'A_T': {
	'code': '21',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'A_R': {
	'code': '22',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'B_T': {
	'code': '23',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'B_R': {
	'code': '24',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'C_T': {
	'code': '25',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'C_R': {
	'code': '26',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'T_LIM_HIGH': {
	'code': '31',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'T_LIM_LOW': {
	'code': '32',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'OUTPUT': {
	'code': '51',
	'read': {
	    'format': '+DDD.DDD',
            'info': """Format is: +0<AE><AS>.<TL><IS><OS>:
            AE: Autotune Error Codes:
            	1: Zero value current limit error
            	2: Current limit cannot reach SET T
            	3: Non-uniform TE I step measured
            	4: Rate sign change
            AS: Autotune Status:
            	0: Normal
            	1: Autotune
            TL: Temperature Limit or Error Limit Status:
            	0: Normal
            	1: Requires cleaning
            IS: Integrator Status:
            	0: OFF
            	1: ON
            OS: Output Status:
            	0: OFF
            	1: ON"""
		},
	'write': {
	    'format': '+DDD.DDD',
	    'alias': {
                'ON': '+000.001',
                'OFF': '+000.000'
            }
	}
    },
    'HALT': {
	'code': '52',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    },
    'LOCAL': {
	'code': '53',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    }
}

usage_msg = ('\n%prog {actions}\n\n' + \
             'Available commands (case-insensitive):\n{cmds}').format(
                 actions = '\n%prog '.join(
                     sorted([ allowed_actions[key]['usage'] \
                       for key in allowed_actions.keys() ])
                 ),
                 cmds = ', '.join(cmds.keys()))
opt_parser = OptionParser(
    usage = usage_msg,
    option_list = [
        make_option('-a', '--address',
                    type = 'int',
                    dest = 'address',
                    help = ('Address of unit: {min} to {max}. ' + \
                            'Default is {default}.').format(
                                min = min_unit_address,
                                max = max_unit_address,
                                default = default_unit_address),
                    metavar = 'UNIT_ID',
                    default = default_unit_address
                ),
        make_option('-i', '--interval',
                    type = 'float',
                    dest = 'interval',
                    help = ('Only used for plotting: number of seconds ' + \
                            'between data points. ' + \
                            'Default is {default}.').format(
                                default = default_plot_interval),
                    metavar = 'SECONDS',
                    default = default_plot_interval
                ),
        make_option('-l', '--log-file',
                    type = 'string',
                    dest = 'log_file',
                    help = ('Only used for plotting: path to log file. ' + \
                            'Default is ./{name}_<date_time>.log').format(
                                name = exec_name),
                    metavar = 'FILE'
                ),
        make_option('-d', '--log-dir',
                    type = 'string',
                    dest = 'log_dir',
                    help = 'Only used for plotting: base directory ' + \
                    "for log files. Default is '.'. This option is " + \
                    'ignored if --log-file is present.',
                    metavar = 'DIR',
                    default = ''
                )
        ]
    )

###############################################################################
##################################### MAIN ####################################
###############################################################################

if os.geteuid() != 0:
    print('Error: Must run as root', file = sys.stderr)
    sys.exit(1)

# must specify action
if len(sys.argv) < 2:
    usage()
    
action = sys.argv[1]

if action.upper() in cmds.keys():
    action = 'single'

if action not in allowed_actions.keys():
    usage()

if len(sys.argv) - 2 not in allowed_actions[action]['num_args']:
    usage()

status = allowed_actions[action]['callable'](sys.argv[1:])
if status is None:
    status = 0
sys.exit(status)
