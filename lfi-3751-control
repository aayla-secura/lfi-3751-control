#!/usr/bin/env python3

###############################################################################
#
# Copyright (C) 2015 Aleksandrina Nikolova <aayla.secura.1138@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
#
# A control file for the LFI-3751 temperature controller
# Requires seriald, regex and matplotlib

# to do:
# set timeout for response based on delta_set_t
# ? meaningful exit error codes
# ? device commands description / man page / print usage to pager

import argparse
import os
import random
import regex
import signal
import socket
import sys
from actions import ActionContainer
from difflib import ndiff
from glob import iglob
from matplotlib import rcParams, animation, pyplot, ticker
from matplotlib.widgets import SpanSelector, Button
from matplotlib.transforms import Bbox
from seriald import SerialDaemon
from serial import Serial, EIGHTBITS, PARITY_NONE, STOPBITS_ONE
from statistics import mean
from textwrap import TextWrapper
from time import time, sleep, strftime

###############################################################################
#################################### GLOBAL ###################################
###############################################################################

exec_name = os.path.basename(__file__)
seriald_config_file = None
config_file = '/etc/{name}.conf'.format(name = exec_name)
pidfile_dir = '/var/run'
socket_dir = '/var/run'
pidfile_name = '{name}_<id>.pid'.format(name = exec_name)
socket_name = '{name}_<id>.socket'.format(name = exec_name)
socket_timeout = 1            # timeout in seconds for socket.recv()
data_encoding = 'utf-8'       # encoding of data transmitted over socket

################################### PLOTTING ##################################

log_dir = os.path.join(os.getcwd(), 'log') # directory to store logs from plots
plot_interval = 2             # seconds between data acquisition
temp_step = 10                # mK between data points for response curve
start_temp = 25               # start T in C for response curve
stop_temp = 65                # stop T in C for response curve
response_samples = 10         # number of samples for temperature stabilization
temp_error = 0.5              # max allowed sum of abs deviation in temperature
response_timeout = 300        # seconds to wait for temperature stabilization

############################# SERIAL CONFIGURATION ############################

device_aliases = {}           # translates unit address to device (tty)
unit_aliases = {}             # translates unit address to device name
serial_port = '/dev/ttyS0'    # default path to device file
baudrate = 19200
bytesize = EIGHTBITS
parity = PARITY_NONE
stopbits = STOPBITS_ONE
xonxoff =  True
serial_timeout = 0.5          # timeout in seconds for serial.read()

################################# DATA FORMAT #################################

unit_type = '1'	              # must be 1 (signifies temperature controller)
unit_address = 1              # default unit address
min_unit_address = 1          # first allower address
max_unit_address = 99         # last allower address
cmd_char = '!'	              # commands to the device must start with !
cmd_length = 15	              # and must be 15 bytes long excluding FCS
reply_length = 21             # device sends 21 bytes of data
discard_invalid = False       # whether or not to accept partially read reply
first_data_char = 10          # bytes 10 to 17 are the data field in the reply
last_data_char = 17
read_char = '1'	              # 1 for read commands, 2 for write commands
write_char = '2'
temp_lims = '-199.900 +199.900'	# temperature limits
res_lims = '+000.000 +499.900'	# resistance limits
device_commands = {
    'ACT_T': {
	'code': '01',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'ACT_R': {
	'code': '02',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'SET_T': {
	'code': '03',
        'read': {
	    'format': '+DDD.DDD'
        },
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'SET_R': {
	'code': '04',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'TE_I': {
	'code': '05',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'TE_V': {
	'code': '06',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'LIM_I_POS': {
	'code': '07',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +005.000'
	}
    },
    'LIM_I_NEG': {
	'code': '08',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '-005.000 +000.000'
	}
    },
    'AUX_T': {
	'code': '09',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'P': {
	'code': '10',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +100.000',
            'alias': {
                'AUTO_S': '-002.000',
                'AUTO_D': '-001.000'
            }
	}
    },
    'I': {
	'code': '11',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.400 +010.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'D': {
	'code': '12',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+001.000 +100.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'A_T': {
	'code': '21',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'A_R': {
	'code': '22',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'B_T': {
	'code': '23',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'B_R': {
	'code': '24',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'C_T': {
	'code': '25',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'C_R': {
	'code': '26',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'T_LIM_HIGH': {
	'code': '31',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'T_LIM_LOW': {
	'code': '32',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'OUTPUT': {
	'code': '51',
	'read': {
	    'format': '+DDD.DDD',
            'info': """Format is: +0<AE><AS>.<TL><IS><OS>:
            AE: Autotune Error Codes:
            	0: No error
            	1: Zero value current limit error
            	2: Current limit cannot reach SET T
            	3: Non-uniform TE I step measured
            	4: Rate sign change
            AS: Autotune Status:
            	0: Normal
            	1: Autotune
            TL: Temperature Limit or Error Limit Status:
            	0: Normal
            	1: Requires cleaning
            IS: Integrator Status:
            	0: OFF
            	1: ON
            OS: Output Status:
            	0: OFF
            	1: ON"""
		},
	'write': {
	    'format': '+DDD.DDD',
	    'alias': {
                'ON': '+000.001',
                'OFF': '+000.000'
            }
	}
    },
    'HALT': {
	'code': '52',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    },
    'LOCAL': {
	'code': '53',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    }
}

###############################################################################
################################ DAEMON RELATED ###############################
###############################################################################

def get_pid(pidfile_path):
    if not os.path.exists(pidfile_path):
        return None
    
    with open(pidfile_path, 'r') as pidfile:
        return int(pidfile.readline().strip())

def get_pidfile(unit):
    return os.path.join(
        pidfile_dir,
        pidfile_name.replace('<id>', unit))

def get_socket(unit):
    return os.path.join(
        socket_dir,
        socket_name.replace('<id>', unit))

def daemon_start(user_dict):
    unit = user_dict['unit']
    serial_port = user_dict['device']
    if not os.path.exists(serial_port):
        print('No such file: {tty}!'.format(tty = serial_port),
              file = sys.stderr)
        
    daemon = SerialDaemon(
        name = exec_name,
        config_file_path = seriald_config_file,
        pidfile_path = get_pidfile(unit),
        socket_path = get_socket(unit),
        data_encoding = data_encoding,
        reply_length_strict = discard_invalid,
        port = serial_port,
        baudrate = baudrate,
        bytesize = bytesize,
        parity = parity,
        stopbits = stopbits,
        xonxoff = xonxoff,
        timeout = serial_timeout
    )
    daemon.start()
    return 0
    
def daemon_stop(user_dict):
    unit = user_dict['unit']
    
    pid = get_pid(get_pidfile(unit))
    if pid is None:
        return 1
    
    try:
        os.kill(pid, signal.SIGTERM)
    except OSError:
        print('Could not kill process {pid}'.format(pid = pid),
              file = sys.stderr)
        return 1

    return 0

def daemon_restart(user_dict):
    status = daemon_stop(user_dict)
    if status != 0:
        return status
    
    sleep(1)	# wait for pidfile lock
    return daemon_start(user_dict)

def daemon_status(user_dict):
    instances = {}
    pidbase = get_pidfile('')
    for inst_pidfile in iglob(get_pidfile('*')):
        pid = get_pid(inst_pidfile)
        if pid is None:
            # not running instance
            continue
        
        # extract the unit address from the file name
        inst_unit = ''
        for char in ndiff(inst_pidfile, pidbase):
            if char[0] != ' ':
                inst_unit = inst_unit + char[-1]
        instances[inst_unit] = pid
        
    if not instances:
        print('No running instances.')
        return 1
        
    for unit, pid in sorted(instances.items()):
        soc = connect_to_socket(unit)
        soc.sendall('device'.encode(data_encoding))
        try:
            device = soc.recv(1024).decode(data_encoding)
        except socket.timeout:
            device = 'busy'
            
        print('PID {pid!s} communicates with unit {unit} ({dev})'.format(
            pid = pid,
            unit = unit,
            dev = device))
    return 0
    
def daemon_reload_config(user_dict):
    unit = user_dict['unit']
    
    pid = get_pidfile(unit)
    if pid is None:
        return 1
    
    try:
        os.kill(pid, signal.SIGHUP)
    except OSError:
        print('Could not send SIGHUP to process {pid}'.format(pid = pid),
              file = sys.stderr)
        return 1
    
    return 0

def interact(user_dict):
    def prompt_msg():
        print(('Communicating with unit {unit}.\nEnter "command ' + \
               '[value] [--unit]".\nValues are optional, their ' + \
               'presence indicates a write command.\nIf you have ' + \
               'specified a unit on the\ninitial command line, ' + \
               'it will take precedence over the default value.\n\n' + \
               'Enter on blank line to quit.').format(unit = unit))

    def error_msg():
        print('Invalid syntax or device command!')

    # unit specified on the command line takes precedence
    unit = user_dict['unit']
    
    soc = connect_to_socket(unit)
    if soc is None:
        return 1
    
    try:
        prompt_msg()
        while True:
            print('\n>', end = ' ')
            try:
                new_input = input()
            except EOFError:
                break
            
            if new_input == '':
                break
            
            status, user_dict = process_input(
                new_input.split(' '),
                use_defaults = False
            )
            
            if status != 0:
                error_msg()
                continue

            cmds = user_dict['command']
            try:
                unit = user_dict['unit']
            except AttributeError:
                pass
            else:
                if get_socket(unit) != soc.getsockname():
                    soc_new = connect_to_socket(unit)
                    if soc_new is None:
                        continue
                    soc.close()
                    soc = soc_new

            try:
                command = cmds[1]                    
            except IndexError:
                error_msg()
                continue
            
            try:
                value = cmds[2]
            except IndexError:
                value = ''
                
            send_cmd(command, value, unit, soc = soc)
            
    except KeyboardInterrupt:
        pass
    
    soc.close()
    return 0

def plot(action, user_dict):
    
    ################################### MISC ##################################
    
    # find the last modified log file for this unit
    # this assumes the filename contains 'unit<id> and ends with .log'
    def find_last_modified():
        if log_dir:
            root = '{root}/'.format(root = log_dir)
        else:
            root = ''

        files = iglob('{root}*unit{unit}*.log'.format(
            root = root,
            unit = unit))

        try:
            last_file_path = max(files, key = os.path.getmtime)
        except ValueError:
            # no matching files
            return None, []

        with open(last_file_path, mode = 'r') as last_file:
            headline = last_file.readline()[1:]

        cmds = [cmd for cmd in headline.split()
                if cmd not in ['time/s', 'SET_T']]

        return last_file_path, cmds
        
    # read in time of last data point from the log we're appending to
    def get_last_timestamp(log_path, time_field = 0):
        with open(log_path, mode = 'rb') as log_file:
            # jump to the second last byte and look backwards for newline
            log_file.seek(-2, os.SEEK_END)
            while log_file.read(1) != b'\n':
                log_file.seek(-2, os.SEEK_CUR)
            return float(log_file.readline().split()[time_field])
            
    
    # find positions of items in the sorted array U item[i]
    # ala numpy's searchsorted
    # both arguments must support subscripting and all items must be numeric
    def searchsorted(array, items):
        try:
            items[0]
        except TypeError:
            items  = [ items ]
            
        # default position is at the end of array
        items_indices = [len(array)] * len(items)
        for array_id, array_el in enumerate(array):
            for item_id, item in enumerate(items):
                if array_el >= item and items_indices[item_id] == len(array):
                    # found a position inside array for item j
                    items_indices[item_id] = array_id
    
        return items_indices
    
    ############################ BUTTON AND EVENTS ############################
    
    # mouse was moved
    def mouse_onmove(event):
        if event.xdata is None:
            return
        
        coords_label.set_text('x = {x:.3f}, y = {y:.3f}'.format(
            x = event.xdata,
            y = event.ydata
        ))
    
    # span selection completed
    def span_onselect(xmin, xmax):
        run.pause = False
        imin, imax = searchsorted(xdata, (xmin, xmax))
        imax = min(len(xdata) - 1, imax)
        imin = min(len(xdata) - 1, imin)
    
        if imin == imax:
            return
        
        ymin, ymax = axes.get_ylim()
        ylim_padding_abs = ylim_padding * (ymax - ymin)
        thisx = xdata[imin:imax]
        thisy = ydata[imin:imax]
        line_lower.set_data(thisx, thisy)
        axes_lower.set_xlim(thisx[0], thisx[-1])
        axes_lower.set_ylim(
            min(thisy) - ylim_padding_abs,
            max(thisy) + ylim_padding_abs
        )
    
    # mouse was movied while span selection was active
    def span_onmove(xmin, xmax):
        run.pause = True
    
    # clear both graphs
    def clear_graphs(event):
        del xdata[:]
        del ydata[:]
        run.miny, run.maxy = None, None
        line.set_data(xdata, ydata)
        line_lower.set_data(xdata, ydata)
        pyplot.draw()
    
    # save figure to file
    def save_image(event):
        axes_extent = axes.get_window_extent().transformed(
            fig.dpi_scale_trans.inverted())
        axes_lower_extent = axes_lower.get_window_extent().transformed(
            fig.dpi_scale_trans.inverted())
        fig_width, fig_height = fig.get_size_inches()
        vpadding = 0.5    # in inches
        fig.savefig(
            '{cmd}_full_range_{time}.png'.format(
                cmd = query_cmds[0],
                time = strftime('%Y-%m-%d_%H-%M-%S')),
            bbox_inches = Bbox.from_bounds(
                0,
                axes_extent.bounds[1] - vpadding,
                fig_width,
                axes_extent.bounds[3] + 2 * vpadding)) # include title
        fig.savefig(
            '{cmd}_zoomed_range_{time}.png'.format(
                cmd = query_cmds[0],
                time = strftime('%Y-%m-%d_%H-%M-%S')),
            bbox_inches = Bbox.from_bounds(
                0,
                axes_lower_extent.bounds[1] - vpadding,
                fig_width,
                axes_lower_extent.bounds[3] + 1.2 * vpadding))
    
    # window was resized
    def resize_objects(event = None):
        # in pixels
        toolbar_hpos = 20
        toolbar_vpos = 10
        button_width = 40
        button_height = 25
        button_padding = 20
        coords_label_width = 150
        
        left_margin = 80
        right_margin = 30
        top_margin = 20
        bottom_margin = 80
        plot_padding = 140
        fig_width, fig_height = fig.canvas.get_width_height()
        
        # convert to fractions
        pyplot.subplots_adjust(
            left = left_margin / fig_width,
            bottom = bottom_margin / fig_height,
            right = 1 - right_margin / fig_width,
            top = 1 - top_margin / fig_height,
            wspace = 0,
            hspace = plot_padding / fig_height
        )
        button_clear.ax.set_position([
            toolbar_hpos / fig_width,
            toolbar_vpos / fig_height,
            button_width / fig_width,
            button_height / fig_height
        ])
        button_save.ax.set_position([
            (toolbar_hpos + button_width + button_padding ) / fig_width,
            toolbar_vpos / fig_height,
            button_width / fig_width,
            button_height / fig_height
        ])
        coords_label.axes.set_position([
            1 - (coords_label_width + right_margin) / fig_width,
            toolbar_vpos / fig_height,
            coords_label_width / fig_width,
            button_height / fig_height
        ])
    
    ################################### DATA ##################################

    # write headline to log files
    def init_logs():
        if log_to_old:
            return
        
        if action == 'response':
            log_file.write('#time/s\tSET_T\t{data}\n'.format(
                data = '\t'.join(query_cmds)))
            log_file_resp.write('#time/s\tSET_T\tACT_T\tact_t_avg' + \
                                '\tact_t_delta\tsample_time\n')
        else:
            log_file.write('#time/s\t{data}\n'.format(
                data = '\t'.join(query_cmds)))

    # get requested data
    def get_data(query, known = []):
        while True:
            data = []
            for cmd in query:
                status, value = send_cmd(
                    command = cmd,
                    value = '',
                    unit = unit,
                    soc = soc,
                    verbose = False
                )

                if status == 2:
                    # reading reply from device did not succeed, ignore
                    data.append('null')
                    continue
                elif status != 0:
                    # something else went wrong, abort
                    return None

                data.append(value)

            if data[0] == 'null':
                continue

            known = ['{:.3f}'.format(el) for el in known]
            log_file.write('{known}\t{data}\n'.format(
                known = '\t'.join(known),
                data = '\t'.join(data)))

            return float(data[0])

    # response curve data specifics
    def get_response():
        set_temp = start_temp
        if log_to_old:
            start_time = time() - time_offset - interval
        else:
            start_time = time() - time_offset

        cur_time = 0
        while (temp_step > 0 and set_temp <= stop_temp) \
              or (temp_step < 0 and set_temp >= stop_temp):
            status = send_cmd(
                command = 'SET_T',
                value = '{temp!s}'.format(temp = set_temp),
                unit = unit,
                soc = soc,
                verbose = False
            )[0]
            
            if status == 2:
                # reading reply from device did not succeed, retry
                continue
            elif status != 0:
                # something else went wrong, abort
                return
            
            temp_history = []
            
            # wait until temperature stabilizes
            meas_start_time = time()

            while True:
                act_temp = get_data(
                    query_cmds,
                    known = [cur_time, set_temp]
                )
                if act_temp is None:
                    return
                
                error = 0
                if len(temp_history) >= samples:
                    for prev_temp in temp_history:
                        error += abs(act_temp - prev_temp)
                        
                    if error / samples <= max_error / 1000:
                        break
                        
                    temp_history.pop(0)
                        
                temp_history.append(act_temp)

                try:
                    delay = time() - start_time - cur_time
                    sleep(interval - delay)
                except ValueError:
                    pass

                cur_time += interval
                meas_time = time() - meas_start_time
                if meas_time > timeout:
                    break

            log_file_resp.write(
                ('{time:.3f}\t{set_t:.3f}\t{act_t:.3f}\t{act_t_avg:.3f}' + \
                 '\t{act_t_delta:.3f}\t{sample_time:.3f}\n').format(
                     time = cur_time,
                     set_t = set_temp,
                     act_t = act_temp,
                     act_t_avg = mean(temp_history),
                     act_t_delta = error,
                     sample_time = meas_time
                 )
            )
                
            yield set_temp, act_temp
            set_temp += temp_step / 1000
                
    # user requested data specifics
    def get_user_data():
        if log_to_old:
            start_time = time() - time_offset - interval
        else:
            start_time = time() - time_offset
            
        while True:
            cur_time = time() - start_time
            new_data = get_data(
                query_cmds,
                known = [cur_time]
            )
            if new_data is None:
                return
            
            yield cur_time, new_data
            sleep(interval)

    # plotting specifics
    def run(data):
        # update the data
        x, y = data
        if None in (run.maxy, run.miny):
            run.miny = run.maxy = y
            
        xdata.append(x)
        ydata.append(y)
        if len(xdata) > max_data_points:
            xdata.pop(0)
            ypop = ydata.pop(0)
            if ypop == run.maxy:
                run.maxy = max(ydata)
            elif ypop == run.miny:
                run.miny = min(ydata)
            
        if not run.pause:
            run.maxy = max(run.maxy, y)
            run.miny = min(run.miny, y)
            if xdata[0] == x:
                axes_lower.set_xlim(x, x + 0.001)
            else:
                axes.set_xlim(xdata[0], x)
            ymin, ymax = axes.get_ylim()
            ylim_padding_abs = ylim_padding * (ymax - ymin)
            axes.set_ylim(
                run.miny - ylim_padding_abs,
                run.maxy + ylim_padding_abs
            )
            line.set_data(xdata, ydata)
    
        return line,
    
    ################################### INIT ##################################

    query_cmds, unit, interval, log_file_path, log_dir, no_log, \
        continue_log, temp_step, start_temp, stop_temp, samples, max_error, \
        timeout = [ user_dict[key] for key in [
            'command', 'unit', 'interval', 'log_file', 'log_dir', 'no_log',
            'continue_log', 'temp_step', 'start_temp', 'stop_temp',
            'samples', 'temp_error', 'timeout' ] ]
    
    if not query_cmds:
        query_cmds = ['ACT_T', 'TE_I', 'TE_V']
    elif action == 'response' and 'ACT_T' not in query_cmds:
        query_cmds.insert(0, 'ACT_T')
        
    # log files
    time_offset = 0
    log_to_old = False
    if no_log:
        log_file_path = os.devnull
        del query_cmds[1:]		# no need to send additional commands
        
    elif continue_log is not None:
        log_to_old = True
        if continue_log == 'last':
            log, cmds = find_last_modified()
            if log and cmds:
                continue_log = log
                query_cmds = cmds
            else:
                log_to_old = False
                
        log_file_path = continue_log
        time_offset = get_last_timestamp(continue_log)
        
    elif log_file_path is None:
        log_file_path = os.path.join(log_dir,
                                     '{cmd}_unit{unit}_{time}.log'.format(
            cmd = query_cmds[0],
            unit = unit,
            time = strftime('%Y-%m-%d_%H-%M-%S')))
        
    if action == 'response' and not no_log:
        log_resp_file_path = '_response.'.join(
            log_file_path.rsplit('.', 1))
    else:
        log_resp_file_path = os.devnull

    soc = connect_to_socket(unit)
    if soc is None:
        return 1
    
    rcParams['toolbar'] = 'None'
    
    max_data_points = 500
    ylim_padding = 0.1    # y-limit padding in fraction of range
    xdata, ydata = [], []
    fig = pyplot.figure()
    axes = fig.add_subplot(211, axisbg = '#FFFFFF')       # full plot
    axes_lower = fig.add_subplot(212, axisbg = '#FFFFFF') # zoom of user selection
    line, = axes.plot(xdata, ydata, linestyle = '-', marker = '+', lw = 1)
    line_lower, = axes_lower.plot(xdata, ydata, linestyle = '-', marker = '+', lw = 1)
    nooff_formatter = ticker.ScalarFormatter(useOffset = False)
    float_formatter = ticker.FormatStrFormatter('%.3f')
    for ax in (axes, axes_lower):
        ax.set_xlim(0, 1)
        if action == 'response':
            ax.set_xlabel('SET_T / C')
            ax.xaxis.set_major_formatter(float_formatter)
        else:
            ax.set_xlabel('Time / s')
            ax.xaxis.set_major_formatter(nooff_formatter)
        ax.set_ylabel(query_cmds[0])
        ax.yaxis.set_major_formatter(float_formatter)
        ax.grid()
    run.pause = False	# pause plotting while spanning top plot
    run.maxy = None
    run.miny = None
    coords_label = pyplot.text(
        0,
        0,
        'x = {x:.3f}, y = {y:.3f}'.format(
            x = 0,
            y = 0
        ),
        transform = pyplot.axes([0, 0, 0, 0.2]).transAxes
    )
    coords_label.axes.set_axis_off()
    
    button_clear = Button(
        pyplot.axes([0, 0, 0, 0]),
        'Clear'
    )
    button_clear.on_clicked(clear_graphs)
    button_save = Button(
        pyplot.axes([0, 0, 0, 0.1]),
        'Save'
    )
    button_save.on_clicked(save_image)
    
    span = SpanSelector(
        axes,
        span_onselect,
        'horizontal',
        onmove_callback = span_onmove,
        rectprops = {
            'alpha': 0.5,
            'facecolor': 'red'
        })
    
    if action == 'response':
        new_data =  get_response
    else:
        new_data = get_user_data

    with open(log_file_path,
              mode = 'a',
              buffering = 1) as log_file, \
        open(log_resp_file_path,
             mode = 'a',
             buffering = 1) as log_file_resp:


        anim = animation.FuncAnimation(
            fig,
            run,
            frames = new_data,
            init_func = init_logs,
            blit = False,
            interval = 1000,
            repeat = False
        )
        
        resize_objects()
        fig.canvas.mpl_connect('resize_event', resize_objects)
        fig.canvas.mpl_connect('motion_notify_event', mouse_onmove)
        pyplot.show()

    soc.close()
    return 0

def onetime_action(user_dict):
    cmds, unit = [
        user_dict[key] for key in ['command', 'unit']
    ]

    if not cmds:
        return 1
    
    command = cmds[0]
    try:
        value = cmds[1]
    except IndexError:
        value = ''
                
    return send_cmd(command, value, unit)[0]
    
def send_cmd(command, value, unit, soc = None, verbose = True):
    
    status, cmd_str = generate_cmd(command, value, unit)
    data = None
    if status == 0:
        if soc is None:
            # one-time command mode
            soc = connect_to_socket(unit)
            if soc is None:
                return 1, None
            soc_close = True
        else:
            # continuous command mode
            soc_close = False

        # the device is to be halted (does not send a reply)
        if 'format' not in device_commands[command]['read']:
            # 1st byte is 0 => do not read reply from device
            soc.sendall(bytes('0{cmd}'.format(cmd = cmd_str), data_encoding))
        else:
            # read reply_length bytes from device
            soc.sendall('2{length:0>2X}{cmd}'.format(
                length = reply_length,
                cmd = cmd_str
            ).encode(data_encoding))
            try:
                reply = soc.recv(1024).decode(data_encoding)
            except socket.timeout:
                status = 2
            else:
                if len(reply) == reply_length:
                    # data received is certainly valid
                    data = reply[first_data_char - 1 : last_data_char]
                else:
                    # data received is partial, search for data field
                    if value:
                        cmd_type = 'write'
                    else:
                        cmd_type = 'read'
    
                    value_regex = device_commands[command][cmd_type]['format']
                    value_regex = value_regex.replace('+', '[+-]')
                    value_regex = value_regex.replace('D', '[0-9]')
                    value_regex = value_regex.replace('A', '[a-zA-Z0-9_-]')
                    regex_pat = regex.compile(value_regex)
                    matches = regex_pat.findall(reply)
                    if len(matches) == 1:
                        data = matches[0]

                if data is None:
                    status = 2
                    
                elif verbose:
                    print('Device replied with: {data}'.format(
                        data = data))
                    if 'info' in device_commands[command]['read']:
                        print(device_commands[command]['read']['info'])
                
                    
        if soc_close:
            soc.close()
            
    return status, data

def connect_to_socket(unit):
    soc = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        soc.connect(get_socket(unit))
    except FileNotFoundError:
        print(('No such file {socket}. ' + \
               'Did you forget to start the daemon?').format(
                   socket = get_socket(unit)),
              file = sys.stderr)
        return None
        
    soc.setblocking(0)
    soc.settimeout(socket_timeout)
    return soc

###############################################################################
################################ SERIAL RELATED ###############################
###############################################################################

def generate_fcs(command):
    fcs = 0
    for char in command:
        fcs = fcs^ord(char)
    return fcs

def generate_cmd(command, value, unit):
    if command not in device_commands:
        print('Invalid device command!', file = sys.stderr)
        return 1, None
        
    if value:
        cmd_type = 'write'
    else:
        cmd_type = 'read'
        
    cmd_code = device_commands[command]['code']
    cmd_values = device_commands[command][cmd_type]
    
    # format must be defined if cmd_type is allowed for this command
    if 'format' not in cmd_values:
        print(('{type} is not a valid operation for command ' +
               '{command}').format(command = command, type = cmd_type),
              file = sys.stderr)
        return 1, None

    if cmd_type == 'write':
        # it is a write command
        cmd_type = write_char
        if 'alias' in cmd_values:
            for alias in cmd_values['alias']:
                # check if it is an alias
                if value.upper() == alias:
                    value = cmd_values['alias'][alias]
                    break
            
        else:
            # else, first check if it is in the right format
            value_regex = value_format = cmd_values['format']
            value_regex = value_regex.replace('+', '[+-]')
            value_regex = value_regex.replace('D', '[0-9]')
            value_regex = value_regex.replace('A', '[a-zA-Z0-9_-]')
            regex_pat = regex.compile(value_regex, regex.I)
                
            if value_format == '+DDD.DDD':
                # value should be numeric
                # accept any valid number and convert it to the right format
                value = '{sign}{value:0>7.3f}'.format(
                    sign = ('+' if value[0].isdigit() or \
                            value[0] == '.' else value[0]),
                    value = abs(float(value)))

            if regex_pat.fullmatch(value) is None:
                print(('{value} is neither a known alias nor in the ' +
                       'allowed format for command {command}').format(
                           command = command,
                           value = value),
                      file = sys.stderr)
                return 1, None
        
            # then check if it is in the allowed range
            if 'range' in cmd_values:
                low_limit, high_limit = [
                    float(el) for el in cmd_values['range'].split(' ')
                ]
                
                if not low_limit <= float(value) <= high_limit:
                    print(('{value} is not within the allowed numerical range ' +
                           'for command {command}').format(
                               command = command,
                               value = value),
                          file = sys.stderr)
                    return 1, None

    else:
        # it is a read command
        cmd_type = read_char
        value = cmd_values['format'].replace('D', '0').replace('A', '0')

    # command to the device must be in the following format
    cmd = '{char}{unit_type}{unit_address}{cmd_type}{cmd_code}{value}'.format(
        char = cmd_char,
        unit_type = unit_type,
        unit_address = unit,
        cmd_type = cmd_type,
        cmd_code = cmd_code,
        value = value
    )
    # append the FCS
    cmd = '{cmd}{fcs:0>2X}'.format(cmd = cmd, fcs = generate_fcs(cmd))
    return 0, cmd

###############################################################################
##################################### MISC ####################################
###############################################################################

def set_unit_number(user_dict):
    unit = None
    try:
        unit = int(user_dict['unit'])
    except ValueError:
        # it's an alias
        unit = user_dict['unit']
        try:
            unit = int(unit_aliases[unit])
        except KeyError:
            print('Unit alias "{alias}" not defined!'.format(
                alias = unit), file = sys.stderr)
            return 1
        except ValueError:
            print('Unit addresses must be integers!', file = sys.stderr)
            return 1
        
    user_dict['unit'] = '{unit!s:0>2}'.format(unit = unit)
    return 0
            
def set_device_fd(user_dict):
    device = None
    try:
        device = user_dict['device']
    except KeyError:
        # it's not explicitly given, try aliases
        try:
            device = device_aliases[user_dict['unit']]
        except KeyError:
            # either alias not defined, or unit not defined
            device = serial_port
            
    # is it a number? Serial defaults to /dev/ttyS? if so        
    if device.isdigit():
        device = '/dev/ttyS{num}'.format(num = device)
    elif device[0] != '/':
        device = '/dev/{tty}'.format(tty = device)

    user_dict['device'] = device

def load_config(config_file):
    
    def set_alias(rule, db):
        regex_pat = regex.compile(r"""\s*
            (?<alias> [^:]+? ) \s* :
            \s* (?P<value> .+ )
            """, regex.X|regex.I)
        
        match = regex_pat.match(rule)
        if match:
            alias = '{unit!s:0>2}'.format(unit = match.group('alias'))
            val = '{unit!s:0>2}'.format(unit = match.group('value'))
            db[alias] = val
        return
    
    if not os.path.exists(config_file):
        # dummy command required by parser
        return process_input(['start'])
    
    with open(config_file, 'r') as conf:

        regex_pat = regex.compile(r"""\s* (?|
            (?P<option>
              device |
              alias |
              pidfile[-_]dir |
	      socket[-_]dir |
              socket[-_]timeout |
              serial[-_]timeout |
              discard[-_]invalid |
              min[-_]unit[-_]address |
              max[-_]unit[-_]address |
              unit[-_]address |
              plot[-_]interval |
              log[-_]dir |
              temp[-_]step |
              start[-_]temp |
              stop[-_]temp |
              response[-_]samples |
              temp[-_]error |
              response[-_]timeout
	    ) \s* (?: =\s* )?
	    (?|
              " (?P<value> [^"]+ ) " |
	      ' (?P<value> [^']+ ) ' |
	        (?P<value> [^#\r\n]+ )
	    ) )
            """, regex.X|regex.I)
        
        line_num = 0
        for line in conf:
            line_num += 1
            
            if line.startswith('#'):
                continue
            
            match = regex_pat.match(line.strip())
            if match:
                # translate the option name to the object's attribute
                opt = match.group('option').lower().replace('-', '_')
                val = match.group('value')
                
                if opt == 'device':
                    set_alias(val, device_aliases)
                    continue
                elif opt == 'alias':
                    set_alias(val, unit_aliases)
                    continue
                    
                if opt.endswith(('file',
                                 'dir',
                                 'path')):
                    # value is a string, do nothing
                    pass
                elif opt == 'discard_invalid':
                    # value must be a boolean
                    if val.lower() not in ['0', '1', 'false', 'true']:
                        print('{conf}: {option} must be a boolean!'.format(
                            conf = config_file,
                            option = opt), file = sys.stderr)
                        return 1, {}
                    
                    elif val.lower() in ['0', 'false']:
                        val = False
                    else:
                        val = True
                else:
                    # value must be numeric
                    val = float(match.group('value'))

                # set the global variable to the new default
                # process_input resets parser's defaults everytime
                # (when needed), so it's ok
                globals()[opt] = val
                
            else:
                print(('{conf}: Unknown option or ' + \
                       'invalid syntax at line {line}').format(
                    conf = config_file,
                    line = line_num), file = sys.stderr)
                return 1, {}

        # let process_input do the rest of the checks
        return process_input([
            'start',
            '--unit', '{:g}'.format(unit_address),
            '--interval', '{:g}'.format(plot_interval),
            '--log-dir', log_dir,
            '--temp-step', '{:g}'.format(temp_step),
            '--start-temp', '{:g}'.format(start_temp),
            '--stop-temp', '{:g}'.format(stop_temp),
            '--samples', '{:g}'.format(response_samples),
            '--temp-error', '{:g}'.format(temp_error),
            '--timeout', '{:g}'.format(response_timeout)
        ])
                
def process_input(user_input, use_defaults = True):
    ap = arg_parser
    
    if use_defaults:
        # make a copy of the global parser, we need to modify it
        ap = argparse.ArgumentParser(
            parents = [arg_parser],
            prog = exec_name,
            usage = arg_parser.usage,
            description = arg_parser.description,
            epilog = arg_parser.epilog,
            formatter_class = arg_parser.formatter_class,
            prefix_chars = arg_parser.prefix_chars,
            fromfile_prefix_chars = arg_parser.fromfile_prefix_chars,
            argument_default= arg_parser.argument_default,
            conflict_handler = arg_parser.conflict_handler,
            add_help = False)
        ap.set_defaults(
            unit = unit_address,
            interval = plot_interval,
            log_dir = log_dir,
            no_log = False,
            temp_step = temp_step,
            start_temp = start_temp,
            stop_temp = stop_temp,
            samples = response_samples,
            temp_error = temp_error,
            timeout = response_timeout
         )

    # the user may specify options in between main action and rest of args
    args, cmds = ap.parse_known_args(user_input)
    if cmds:
        cmds = ap.parse_args(cmds)
        args.command.extend(cmds.command)
    
    # remove action, e.g. plot
    try:
        allowed_actions[args.command[0]]
    except AttributeError:
        if args.command[0].upper() in device_commands:
            action = 'single'
        else:
            usage()
    else:
        action = args.command.pop(0)

    # check if additional args are valid
    try:
        allowed_arguments = allowed_actions[action].allowed_arguments
    except AttributeError:
        pass
    else:
        if allowed_arguments is not None:
            for cmd in args.command:
                if cmd.upper() not in allowed_arguments:
                    usage()

    try:
        args.unit = int(args.unit)
    except (AttributeError, ValueError):
        pass
    else:
        if not min_unit_address <= args.unit <= max_unit_address:
            print(('Unit address must be between {min} and ' +
                   '{max}!').format(min = min_unit_address,
                                    max = max_unit_address),
                  file = sys.stderr)
            return 1, {}
        
    try:
        args.device
    except AttributeError:
        pass
    
    try:
        if args.interval < 0:
            print('Check interval cannot be negative!', file = sys.stderr)
            return 1, {}
    except AttributeError:
        pass

    try:
        if not os.path.isdir(args.log_dir):
            os.mkdir(args.log_dir, mode = 0o755)
    except AttributeError:
        pass

    try:
        if args.continue_log not in [None, 'last'] \
           and not os.path.isfile(args.continue_log):
            print('No such file: {log}'.format(
                log = args.continue_log), file = sys.stderr)
            return 1, {}
    except AttributeError:
        pass

    try:
        if args.temp_step <= 0:
            print('Temperature step must be positive!', file = sys.stderr)
            return 1, {}
    except AttributeError:
        pass

    try:
        if args.stop_temp < args.start_temp:
            args.temp_step = -args.temp_step
    except AttributeError:
        pass

    try:
        if args.samples <= 0:
            print('Response samples must be positive!', file = sys.stderr)
            return 1, {}
    except AttributeError:
        pass

    try:
        if args.temp_error < 0:
            print('Temperature error cannot be negative!', file = sys.stderr)
            return 1, {}
    except AttributeError:
        pass

#    try:
#        if args.timeout <= args.interval * args.samples:
#            print('Response timeout must be larger than samples * interval!', file = sys.stderr)
#            return 1, {}
#    except AttributeError:
#        pass

    user_dict = {}
    for key in vars(args):
        user_dict[key] = getattr(args, key)

    for i, cmd in enumerate(user_dict['command']):
        user_dict['command'][i] = cmd.upper()
        
    user_dict['command'].insert(0, action)
        
    return 0, user_dict

def usage():
    process_input(['--help'])
    
###############################################################################
##################################### MAIN ####################################
###############################################################################

allowed_actions = ActionContainer(call_with_action_name = False)
allowed_actions.add_action(
    'start',
    description = 'Start/stop/restart daemon:',
    usage = '%(prog)s start [--unit=UNIT] [--device=DEV]',
    action = daemon_start,
    allowed_arguments = []
)
allowed_actions.add_action(
    'stop',
    usage = '%(prog)s stop [--unit=UNIT]',
    action = daemon_stop,
    allowed_arguments = []
)
allowed_actions.add_action(
    'restart',
    usage = '%(prog)s restart [--unit=UNIT] [--device=DEV]',
    action = daemon_restart,
    allowed_arguments = []
)
allowed_actions.add_action(
    'status',
    description = 'Print info about running instances',
    usage = '%(prog)s status',
    action = daemon_status,
    allowed_arguments = []
)
allowed_actions.add_action(
    'reload',
    description = 'Reload configuration file:',
    usage = '%(prog)s reload [--unit=UNIT]',
    action = daemon_reload_config,
    allowed_arguments = []
)
allowed_actions.add_action(
    'single',
    description = 'Send single command to device:',
    usage = '%(prog)s <command> [<value>] [--unit=UNIT]',
    action = onetime_action
)
allowed_actions.add_action(
    'interact',
    description = 'Read commands from stdin:',
    usage = '%(prog)s interact [--unit=UNIT]',
    action = interact,
    allowed_arguments = []
)
allowed_actions.add_action(
    'plot',
    description = """Plot reply from first command vs time and log time
                     + replies for all given commands to file. By default
                     it plots ACT_T and logs TE_V and TE_I as well:""",
    usage = '%(prog)s plot [<command> ...] [options]',
    action = plot,
    call_with_action_name = True,
    allowed_arguments = device_commands.keys()
)
allowed_actions.add_action(
    'response',
    description = """Plot and log Tact vs Tset for the specified range
                     using the specified temperature step. Also log all
                     specified commands. By default it logs time, TE_V
                     and TE_I for all points. Irrespective of given commands
                     it also logs average and sum of absolute deviation of
                     T_ACT per sample, as well as stabilization time:""",
    usage = '%(prog)s response [<command> ...] [options]',
    action = plot,
    call_with_action_name = True,
    allowed_arguments = device_commands.keys()
)

arg_parser = argparse.ArgumentParser(
    prog = exec_name,
    usage = '\n' + allowed_actions.usage,
    description = ('available commands (case-insensitive):\n' + \
                   ', '.join(sorted(device_commands))),
    epilog = None,
    argument_default = argparse.SUPPRESS,
#    formatter_class = argparse.ArgumentDefaultsHelpFormatter
)
arg_parser.add_argument('command',
                        nargs = '+',
                        help = argparse.SUPPRESS
)
arg_parser.add_argument('-c', '--config',
                        type = str,
                        dest = 'config',
                        help = ('configuration file to load ' + \
                                '(default: {default!s})'.format(
                                    default = config_file)),
                        metavar = 'FILE',
                        default = config_file
                    )
arg_parser.add_argument('-D', '--device',
                        type = str,
                        dest = 'device',
                        help = ('serial device file descriptor ' + \
                                '(default: {default!s})'.format(
                                default = serial_port)),
                        metavar = 'DEV'
                    )
arg_parser.add_argument('-u', '--unit',
                        type = str,
                        dest = 'unit',
                        help = ('address of unit: {min} to {max} ' + \
                                '(default: {default!s})').format(
                                    min = min_unit_address,
                                    max = max_unit_address,
                                    default = unit_address),
                        metavar = 'UNIT'
                    )
arg_parser.add_argument('-i', '--interval',
                        type = float,
                        dest = 'interval',
                        help = ('number of seconds between data points ' + \
                                '(default: {default!s})'.format(
                                    default = plot_interval)),
                        metavar = 'SECONDS'
                    )
arg_parser.add_argument('-l', '--log-file',
                        type = str,
                        dest = 'log_file',
                        help = ('path to log file; --log-dir option is ' + \
                                'ignored (default: ' + \
                                './<command>_unit<id>_<date_time>.log)'),
                        metavar = 'FILE',
                        default = None
                    )
arg_parser.add_argument('-d', '--log-dir',
                        type = str,
                        dest = 'log_dir',
                        help = ('base directory for log files ' + \
                                '(default: {default!s})'.format(
                                    default = log_dir)),
                        metavar = 'DIR'
                    )
arg_parser.add_argument('-C', '--continue',
                        type = str,
                        dest = 'continue_log',
                        help = ('continue previous log: timestamp is ' + \
                                'offset by the last timestamp in the ' + \
                                'specified file, log commands are read ' + \
                                'from the file (those specified on the ' + \
                                'command line are ignored), --log-file ' + \
                                'option is also ignored; you can omit a ' + \
                                'filename, in which case the last ' + \
                                'modified file matching the pattern ' + \
                                '\'<log_dir>/*unit<unit_id>*.log\' is used.'),
                        metavar = 'FILE',
                        nargs = '?',
                        const = 'last',
                        default = None
                    )
arg_parser.add_argument('-n', '--no-log',
                        action = 'store_true',
                        dest = 'no_log',
                        help = ('do not log; --log-file and --log-dir ' + \
                                'options are ignored ' + \
                                '(default: {default!s})'.format(
                                    default = False))
                    )
arg_parser.add_argument('-t', '--temp-step',
                        type = float,
                        dest = 'temp_step',
                        help = ('step in mK for reponse curve ' + \
                                '(default: {default!s})'.format(
                                    default = temp_step)),
                        metavar = 'TEMP'
                    )
arg_parser.add_argument('-s', '--start-temp',
                        type = float,
                        dest = 'start_temp',
                        help = ('initial temperature in C for response ' + \
                                'curve (default: {default!s})'.format(
                                    default = start_temp)),
                        metavar = 'TEMP'
                    )
arg_parser.add_argument('-S', '--stop-temp',
                        type = float,
                        dest = 'stop_temp',
                        help = ('final temperature in C for response ' + \
                                'curve (default: {default!s})'.format(
                                    default = stop_temp)),
                        metavar = 'TEMP'
                    )
arg_parser.add_argument('-N', '--samples',
                        type = int,
                        dest = 'samples',
                        help = ('number of data points used to ' + \
                                'determine if temperature is stable ' + \
                                '(default: {default!s})'.format(
                                    default = response_samples)),
                        metavar = 'NUMBER'
                    )
arg_parser.add_argument('-e', '--temp-error',
                        type = float,
                        dest = 'temp_error',
                        help = ('maximum (sum of absolute) temperature ' + \
                                'deviation in mK per sample ' + \
                                '(default: {default!s})'.format(
                                    default = temp_error)),
                        metavar = 'TEMP'
                    )
arg_parser.add_argument('-T', '--timeout',
                        type = float,
                        dest = 'timeout',
                        help = ('number of seconds to wait for ' + \
                                'temperature to stabilize; timeout ' + \
                                'does not produce an error ' + \
                                '(default: {default!s})'.format(
                                    default = response_timeout)),
                        metavar = 'SECONDS'
                    )

if os.geteuid() != 0:
    print('Error: Must run as root', file = sys.stderr)
    sys.exit(1)

# must specify action
if len(sys.argv) < 2:
    usage()

status, user_dict = process_input(
    sys.argv[1:],
    use_defaults = False
)
if status != 0:
    sys.exit(status)

action = user_dict['command'].pop(0)

status, conf_dict = load_config(user_dict['config'])
if status != 0:
    sys.exit(status)

# command line options override config file
for opt, val in user_dict.items():
    conf_dict[opt] = val

status = set_unit_number(conf_dict)
if status != 0:
    sys.exit(status)

set_device_fd(conf_dict)

sys.exit(allowed_actions[action](conf_dict))
