#!/usr/bin/env python3

###############################################################################
#
# Copyright (C) 2015 Aleksandrina Nikolova <aayla.secura.1138@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
#
# A control file for the LFI-3751 temperature controller
# Requires seriald, regex and matplotlib

# to do:
# set timeout for response based on delta_set_t
# fix checking for valid arguments
# fix duplicate initial entries in log files
# default values for arguments to send_cmd?

import os
import random
import regex
import signal
import socket
import sys
from matplotlib import rcParams, animation, pyplot, ticker
from matplotlib.widgets import SpanSelector, Button
from matplotlib.transforms import Bbox
from glob import iglob
from optparse import OptionParser, make_option
from seriald import SerialDaemon
from serial import Serial, EIGHTBITS, PARITY_NONE, STOPBITS_ONE
from statistics import mean
from time import time, sleep, strftime

exec_name = os.path.basename(__file__)
pidfile = '/var/run/{name}_<socket_port>.pid'.format(name = exec_name)
config_file = None
socket_host = 'localhost'       # host to connect to
socket_port = 57001             # port to request the daemon to listen on
socket_timeout = 1              # timeout in seconds for socket.recv()
data_encoding = 'utf-8'	        # encoding of data transmitted over socket
plot_interval = 2               # seconds between data acquisition
temp_step = 10                  # mK between data points for response curve
start_temp = 25                 # start T in C for response curve
stop_temp = 65                  # stop T in C for response curve

###############################################################################
################################ DAEMON RELATED ###############################
###############################################################################

def get_pid(pidfile_path):
    if not os.path.exists(pidfile_path):
        return None
    
    with open(pidfile_path, 'r') as pidfile:
        return int(pidfile.readline().strip())
    
def start(user_input):
    # user_input[0] will be 'start', discard it
    status, user_dict = process_input(user_input[1:])
    
    if status != 0:
        usage()
        
    socket_port = user_dict['port']
    serial_port = user_dict['device']
        
    daemon = SerialDaemon(
        name = exec_name,
        config_file_path = config_file,
        pidfile_path = pidfile.replace(
            '<socket_port>', '{port}'.format(port = socket_port)
        ),
        socket_port = socket_port,
        data_encoding = data_encoding,
        reply_length_strict = discard_invalid,
        port = serial_port,
        baudrate = baudrate,
        bytesize = bytesize,
        parity = parity,
        stopbits = stopbits,
        xonxoff = xonxoff,
        timeout = serial_timeout
    )
    daemon.start()
    
def stop(user_input):
    # user_input[0] will be 'stop', discard it
    status, user_dict = process_input(user_input[1:])
    
    if status != 0:
        usage()
        
    socket_port = user_dict['port']
    
    pid = get_pid(pidfile.replace(
        '<socket_port>', '{port}'.format(port = socket_port))
    )
    if pid is None:
        return
    
    try:
        os.kill(pid, signal.SIGTERM)
    except OSError:
        print('Could not kill process {}'.format(pid), file = sys.stderr)

def restart(user_input):
    stop(user_input)
    sleep(1)	# wait for pidfile lock
    start(user_input)

def reload_config(user_input):
    # user_input[0] will be 'reload', discard it
    status, user_dict = process_input(user_input[1:])
    
    if status != 0:
        usage()
        
    socket_port = user_dict['port']
    
    pid = get_pid(pidfile.replace(
        '<socket_port>', '{port}'.format(port = socket_port))
    )
    if pid is None:
        return
    
    try:
        os.kill(pid, signal.SIGHUP)
    except OSError:
        print('Could not send SIGHUP to process {}'.format(pid),
              file = sys.stderr)

# must return 0 on success
def interact(user_input):
    def prompt_msg():
        print('Enter "command value [--address] [--port]".\nValues ' + \
              'are optional, their presence indicates a write command.\n' + \
              'Address is optional, defaults to 1.\nEnter to quit.')

    def error_msg():
        print('Invalid syntax!\n')
        prompt_msg()

    # user_input[0] will be 'interact', discard it
    status, user_dict = process_input(user_input[1:])
    
    if status != 0:
        error_msg()
        
    port = user_dict['port']
    
    soc = connect_to_socket(port)
    try:
        prompt_msg()
        while True:
            new_input = input()
            if new_input == '':
                break
            status, user_dict = process_input(
                new_input.split(' ')
            )
            
            if status != 0:
                error_msg()
                
            cmd, val, port, addr = [
                user_dict[key] for key in [
                    'command',
                    'value',
                    'port',
                    'address'
                ]
            ]
            
            if cmd is None:
                break
            
            if port != soc.getsockname():
                soc.close()
                soc = connect_to_socket(port)
                    
            send_cmd(cmd, val, addr, socket = soc)
            
    except KeyboardInterrupt:
        pass

    soc.close()
    return 0

# must return 0 on success
def plot_realtime(user_input):
    return plot(user_input)

# must return 0 on success
def response_curve(user_input):
    plot(user_input, response_curve = True)

# must return 0 on success
def plot(user_input, response_curve = False):
    
    ################################### MISC ##################################
    
    # find the last modified log file for this unit
    # this assumes the filename contains 'unit<id> and ends with .log'
    def find_last_modified():
        if log_dir:
            root = '{root}/'.format(root = log_dir)
        else:
            root = ''

        files = iglob('{root}*unit{addr}*.log'.format(
            root = root,
            addr = addr))

        try:
            last_file_path = max(files, key = os.path.getmtime)
        except ValueError:
            # no matching files
            return None, []

        with open(last_file_path, mode = 'r') as last_file:
            headline = last_file.readline()[1:]

        cmds = [cmd for cmd in headline.split()
                if cmd not in ['time/s', 'SET_T']]

        return last_file_path, cmds
        
    # read in time of last data point from the log we're appending to
    def get_last_timestamp(log_path, time_field = 0):
        with open(log_path, mode = 'rb') as log_file:
            # jump to the second last byte and look backwards for newline
            log_file.seek(-2, os.SEEK_END)
            while log_file.read(1) != b'\n':
                log_file.seek(-2, os.SEEK_CUR)
            return float(log_file.readline().split()[time_field])
            
    
    # find positions of items in the sorted array U item[i]
    # ala numpy's searchsorted
    # both arguments must support subscripting and all items must be numeric
    def searchsorted(array, items):
        try:
            items[0]
        except TypeError:
            items  = [ items ]
            
        # default position is at the end of array
        items_indices = [len(array)] * len(items)
        for array_id, array_el in enumerate(array):
            for item_id, item in enumerate(items):
                if array_el >= item and items_indices[item_id] == len(array):
                    # found a position inside array for item j
                    items_indices[item_id] = array_id
    
        return items_indices
    
    ############################ BUTTON AND EVENTS ############################
    
    # mouse was moved
    def mouse_onmove(event):
        if event.xdata is None:
            return
        
        coords_label.set_text('x = {x:.3f}, y = {y:.3f}'.format(
            x = event.xdata,
            y = event.ydata
        ))
    
    # span selection completed
    def span_onselect(xmin, xmax):
        run.pause = False
        imin, imax = searchsorted(xdata, (xmin, xmax))
        imax = min(len(xdata) - 1, imax)
        imin = min(len(xdata) - 1, imin)
    
        if imin == imax:
            return
        
        ymin, ymax = axes.get_ylim()
        ylim_padding_abs = ylim_padding * (ymax - ymin)
        thisx = xdata[imin:imax]
        thisy = ydata[imin:imax]
        line_lower.set_data(thisx, thisy)
        axes_lower.set_xlim(thisx[0], thisx[-1])
        axes_lower.set_ylim(
            min(thisy) - ylim_padding_abs,
            max(thisy) + ylim_padding_abs
        )
    
    # mouse was movied while span selection was active
    def span_onmove(xmin, xmax):
        run.pause = True
    
    # clear both graphs
    def clear_graphs(event):
        del xdata[:]
        del ydata[:]
        run.miny, run.maxy = None, None
        line.set_data(xdata, ydata)
        line_lower.set_data(xdata, ydata)
        pyplot.draw()
    
    # save figure to file
    def save_image(event):
        axes_extent = axes.get_window_extent().transformed(
            fig.dpi_scale_trans.inverted())
        axes_lower_extent = axes_lower.get_window_extent().transformed(
            fig.dpi_scale_trans.inverted())
        fig_width, fig_height = fig.get_size_inches()
        vpadding = 0.5    # in inches
        fig.savefig(
            '{cmd}_full_range_{time}.png'.format(
                cmd = query_cmds[0],
                time = strftime('%Y-%m-%d_%H-%M-%S')),
            bbox_inches = Bbox.from_bounds(
                0,
                axes_extent.bounds[1] - vpadding,
                fig_width,
                axes_extent.bounds[3] + 2 * vpadding)) # include title
        fig.savefig(
            '{cmd}_zoomed_range_{time}.png'.format(
                cmd = query_cmds[0],
                time = strftime('%Y-%m-%d_%H-%M-%S')),
            bbox_inches = Bbox.from_bounds(
                0,
                axes_lower_extent.bounds[1] - vpadding,
                fig_width,
                axes_lower_extent.bounds[3] + 1.2 * vpadding))
    
    # window was resized
    def resize_objects(event = None):
        # in pixels
        toolbar_hpos = 20
        toolbar_vpos = 10
        button_width = 40
        button_height = 25
        button_padding = 20
        coords_label_width = 150
        
        left_margin = 80
        right_margin = 30
        top_margin = 20
        bottom_margin = 80
        plot_padding = 140
        fig_width, fig_height = fig.canvas.get_width_height()
        
        # convert to fractions
        pyplot.subplots_adjust(
            left = left_margin / fig_width,
            bottom = bottom_margin / fig_height,
            right = 1 - right_margin / fig_width,
            top = 1 - top_margin / fig_height,
            wspace = 0,
            hspace = plot_padding / fig_height
        )
        button_clear.ax.set_position([
            toolbar_hpos / fig_width,
            toolbar_vpos / fig_height,
            button_width / fig_width,
            button_height / fig_height
        ])
        button_save.ax.set_position([
            (toolbar_hpos + button_width + button_padding ) / fig_width,
            toolbar_vpos / fig_height,
            button_width / fig_width,
            button_height / fig_height
        ])
        coords_label.axes.set_position([
            1 - (coords_label_width + right_margin) / fig_width,
            toolbar_vpos / fig_height,
            coords_label_width / fig_width,
            button_height / fig_height
        ])
    
    ################################### DATA ##################################

    # write headline to log files
    def init_logs():
        if log_to_old:
            return
        
        if response_curve:
            log_file.write('#time/s\tSET_T\t{data}\n'.format(
                data = '\t'.join(query_cmds)))
            log_file_resp.write('#time/s\tSET_T\tACT_T\tact_t_avg' + \
                                '\tact_t_delta\tsample_time\n')
        else:
            log_file.write('#time/s\t{data}\n'.format(
                data = '\t'.join(query_cmds)))

    # get requested data
    def get_data(query, known = []):
        while True:
            data = []
            for cmd in query:
                status, val = send_cmd(
                    cmd,
                    '',
                    addr,
                    socket = soc,
                    verbose = False
                )

                if status == 2:
                    # reading reply from device did not succeed, ignore
                    data.append('null')
                    continue

                data.append(val)

            if data[0] == 'null':
                continue

            known = ['{:.3f}'.format(el) for el in known]
            log_file.write('{known}\t{data}\n'.format(
                known = '\t'.join(known),
                data = '\t'.join(data)))

            return float(data[0])

    # response curve data specifics, response_curve is True
    def get_response():
        set_temp = start_temp
        if log_to_old:
            start_time = time() - time_offset - interval
        else:
            start_time = time() - time_offset
        
        while (temp_step > 0 and set_temp <= stop_temp) \
              or (temp_step < 0 and set_temp >= stop_temp):
            send_cmd(
                'SET_T',
                '{temp!s}'.format(temp = set_temp),
                addr,
                socket = soc,
                verbose = False
            )
            temp_history = []
            error_samples = 10       # number of previous samples to look at
            max_error = 0.5 / 1000   # stabilize to that temp in C (per sample)
            
            # wait until temperature stabilizes
            meas_start_time = time()
            timeout = 300            # in seconds
            while True:
                cur_time = time() - start_time
                act_temp = get_data(
                    query_cmds,
                    known = [cur_time, set_temp]
                )
                if len(temp_history) >= error_samples:
                    error = 0
                    for prev_temp in temp_history:
                        error += abs(act_temp - prev_temp)
                        
                    if error / error_samples <= max_error:
                        break
                        
                    temp_history.pop(0)
                        
                temp_history.append(act_temp)
                sleep(interval)
                meas_time = time() - meas_start_time
                if meas_time > timeout:
                    break

            log_file_resp.write(
                ('{time:.3f}\t{set_t:.3f}\t{act_t:.3f}\t{act_t_avg:.3f}' + \
                 '\t{act_t_delta:.3f}\t{sample_time:.3f}\n').format(
                     time = cur_time,
                     set_t = set_temp,
                     act_t = act_temp,
                     act_t_avg = mean(temp_history),
                     act_t_delta = error,
                     sample_time = meas_time
                 )
            )
                
            yield set_temp, act_temp
            set_temp += temp_step / 1000
                
        return
    
    # user requested data specifics, response_curve is False
    def get_user_data():
        if log_to_old:
            start_time = time() - time_offset - interval
        else:
            start_time = time() - time_offset
        
        while True:
            cur_time = time() - start_time
            new_data = get_data(
                query_cmds,
                known = [cur_time]
            )
            yield cur_time, new_data
            sleep(interval)

    # plotting specifics
    def run(data):
        # update the data
        x, y = data
        if None in (run.maxy, run.miny):
            run.miny = run.maxy = y
            
        xdata.append(x)
        ydata.append(y)
        if len(xdata) > max_data_points:
            xdata.pop(0)
            ypop = ydata.pop(0)
            if ypop == run.maxy:
                run.maxy = max(ydata)
            elif ypop == run.miny:
                run.miny = min(ydata)
            
        if not run.pause:
            run.maxy = max(run.maxy, y)
            run.miny = min(run.miny, y)
            if xdata[0] == x:
                axes_lower.set_xlim(x, x + 0.001)
            else:
                axes.set_xlim(xdata[0], x)
            ymin, ymax = axes.get_ylim()
            ylim_padding_abs = ylim_padding * (ymax - ymin)
            axes.set_ylim(
                run.miny - ylim_padding_abs,
                run.maxy + ylim_padding_abs
            )
            line.set_data(xdata, ydata)
    
        return line,
    
    ################################### INIT ##################################

    # user_input[0] will be 'plot', discard it
    status, user_dict = process_input(user_input[1:], multi_cmds = True)
    
    if status != 0:
        return status
    
    query_cmds, addr, interval, port, log_file_path, log_dir, no_log, \
        continue_log, temp_step, start_temp, stop_temp = [
            user_dict[key] for key in [
                'commands', 'address', 'interval', 'port',
                'log_file', 'log_dir', 'no_log', 'continue_log',
                'temp_step', 'start_temp', 'stop_temp'
            ]
        ]
    
    if len(query_cmds) == 0:
        query_cmds = ['ACT_T', 'TE_I', 'TE_V']
    elif response_curve and 'ACT_T' not in query_cmds:
        query_cmds.insert(0, 'ACT_T')
        
    # log files
    time_offset = 0
    log_to_old = False
    if no_log:
        log_file_path = os.devnull
        del query_cmds[1:]		# no need to send additional commands
        
    elif continue_log is not None:
        log_to_old = True
        if continue_log == 'last':
            log, cmds = find_last_modified()
            if log and cmds:
                continue_log = log
                query_cmds = cmds
            else:
                log_to_old = False
                
        log_file_path = continue_log
        time_offset = get_last_timestamp(continue_log)
        
    elif log_file_path is None:
        log_file_path = os.path.join(log_dir,
                                     '{cmd}_unit{addr}_{time}.log'.format(
            cmd = query_cmds[0],
            addr = addr,
            time = strftime('%Y-%m-%d_%H-%M-%S')))
        
    if response_curve and not no_log:
        log_resp_file_path = '_response.'.join(
            log_file_path.rsplit('.', 1))
    else:
        log_resp_file_path = os.devnull

    soc = connect_to_socket(port)
    
    rcParams['toolbar'] = 'None'
    
    max_data_points = 500
    ylim_padding = 0.1    # y-limit padding in fraction of range
    xdata, ydata = [], []
    fig = pyplot.figure()
    axes = fig.add_subplot(211, axisbg = '#FFFFFF')       # full plot
    axes_lower = fig.add_subplot(212, axisbg = '#FFFFFF') # zoom of user selection
    line, = axes.plot(xdata, ydata, linestyle = '-', marker = '+', lw = 1)
    line_lower, = axes_lower.plot(xdata, ydata, linestyle = '-', marker = '+', lw = 1)
    nooff_formatter = ticker.ScalarFormatter(useOffset = False)
    float_formatter = ticker.FormatStrFormatter('%.3f')
    for ax in (axes, axes_lower):
        ax.set_xlim(0, 1)
        if response_curve:
            ax.set_xlabel('SET_T / C')
            ax.xaxis.set_major_formatter(float_formatter)
        else:
            ax.set_xlabel('Time / s')
            ax.xaxis.set_major_formatter(nooff_formatter)
        ax.set_ylabel(query_cmds[0])
        ax.yaxis.set_major_formatter(float_formatter)
        ax.grid()
    run.pause = False	# pause plotting while spanning top plot
    run.maxy = None
    run.miny = None
    coords_label = pyplot.text(
        0,
        0,
        'x = {x:.3f}, y = {y:.3f}'.format(
            x = 0,
            y = 0
        ),
        transform = pyplot.axes([0, 0, 0, 0.2]).transAxes
    )
    coords_label.axes.set_axis_off()
    
    button_clear = Button(
        pyplot.axes([0, 0, 0, 0]),
        'Clear'
    )
    button_clear.on_clicked(clear_graphs)
    button_save = Button(
        pyplot.axes([0, 0, 0, 0.1]),
        'Save'
    )
    button_save.on_clicked(save_image)
    
    span = SpanSelector(
        axes,
        span_onselect,
        'horizontal',
        onmove_callback = span_onmove,
        rectprops = {
            'alpha': 0.5,
            'facecolor': 'red'
        })
    
    if response_curve:
        new_data =  get_response
    else:
        new_data = get_user_data

    with open(log_file_path,
              mode = 'a',
              buffering = 1) as log_file, \
        open(log_resp_file_path,
             mode = 'a',
             buffering = 1) as log_file_resp:

        anim = animation.FuncAnimation(
            fig,
            run,
            frames = new_data,
            init_func = init_logs,
            blit = False,
            interval = 10,
            repeat = False
        )
    
        resize_objects()
        fig.canvas.mpl_connect('resize_event', resize_objects)
        fig.canvas.mpl_connect('motion_notify_event', mouse_onmove)
        
        try:
            pyplot.show()
        except KeyboardInterrupt:
            pass

    soc.close()
    return 0

# must return 0 on success
def onetime_action(user_input):
    status, user_dict = process_input(user_input)
    
    if status == 0:
        cmd, val, addr, port = [
            user_dict[key] for key in ['command', 'value', 'address', 'port']
        ]
        status = send_cmd(cmd, val, addr, port = port)[0]
        
    return status
    
# must return 0 on success
def send_cmd(cmd, val, addr, socket = None, port = socket_port, verbose = True):
    
    status, cmd_str = generate_cmd(cmd, val, addr)
    data = None
    if status == 0:
        if socket is None:
            # one-time command mode
            socket = connect_to_socket(port)
            soc_close = True
        else:
            # continuous command mode
            soc_close = False

        # the device is to be halted (does not send a reply)
        if 'format' not in cmds[cmd]['read']:
            # 1st byte is 0 => do not read reply from device
            socket.sendall(bytes('0{}'.format(cmd_str), data_encoding))
        else:
            # read reply_length bytes from device
            socket.sendall(bytes('2{length:0>2X}{cmd}'.format(
                length = reply_length,
                cmd = cmd_str), data_encoding))
            try:
                reply = socket.recv(1024).decode(data_encoding)
#            except socket.timeout:
            except:
                status = 2
            else:
                if len(reply) == reply_length:
                    # data received is certainly valid
                    data = reply[first_data_char - 1 : last_data_char]
                else:
                    # data received is partial, search for data field
                    if val:
                        cmd_type = 'write'
                    else:
                        cmd_type = 'read'
    
                    val_regex = cmds[cmd][cmd_type]['format']
                    val_regex = val_regex.replace('+', '[+-]')
                    val_regex = val_regex.replace('D', '[0-9]')
                    val_regex = val_regex.replace('A', '[a-zA-Z0-9_-]')
                    regex_pat = regex.compile(val_regex)
                    matches = regex_pat.findall(reply)
                    if len(matches) == 1:
                        data = matches[0]

                if data is None:
                    status = 2
                    
                elif verbose:
                    print('Device replied with: {data}'.format(
                        data = data))
                    if 'info' in cmds[cmd]['read']:
                        print(cmds[cmd]['read']['info'])
                
                    
        if soc_close:
            socket.close()

    return status, data

def connect_to_socket(port = socket_port):
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        soc.connect((socket_host, port))
    except ConnectionRefusedError:
        print('Connection refused. Did you forget to start the daemon?',
              file = sys.stderr)
        sys.exit(2)
        
    soc.setblocking(0)
    soc.settimeout(socket_timeout)
    return soc

###############################################################################
################################ SERIAL RELATED ###############################
###############################################################################

def generate_fcs(cmd):
    fcs = 0
    for char in cmd:
        fcs = fcs^ord(char)
    return fcs

# must return 0 on success
def generate_cmd(cmd, val, addr):
    if val:
        cmd_type = 'write'
    else:
        cmd_type = 'read'
        
    cmd_code = cmds[cmd]['code']
    cmd_vals = cmds[cmd][cmd_type]
    
    # format must be defined if cmd_type is allowed for this command
    if 'format' not in cmd_vals:
        print(('{type} is not a valid operation for command ' +
               '{cmd}').format(cmd = cmd, type = cmd_type),
              file = sys.stderr)
        return 1, None

    if cmd_type == 'write':
        # it is a write command
        cmd_type = write_char
        if 'alias' in cmd_vals:
            for alias in cmd_vals['alias'].keys():
                # check if it is an alias
                if val.upper() == alias:
                    val = cmd_vals['alias'][alias]
                    break
            
        else:
            # else, first check if it is in the right format
            val_regex = val_format = cmd_vals['format']
            val_regex = val_regex.replace('+', '[+-]')
            val_regex = val_regex.replace('D', '[0-9]')
            val_regex = val_regex.replace('A', '[a-zA-Z0-9_-]')
            regex_pat = regex.compile(val_regex, regex.I)
                
            if val_format == '+DDD.DDD':
                # value should be numeric
                # accept any valid number and convert it to the right format
                val = '{sign}{val:0>7.3f}'.format(
                    sign = ('+' if val[0].isdigit() or \
                            val[0] == '.' else val[0]),
                    val = abs(float(val)))

            if regex_pat.fullmatch(val) is None:
                print(('{val} is neither a known alias nor in the ' +
                       'allowed format for command {cmd}').format(
                           cmd = cmd,
                           val = val),
                      file = sys.stderr)
                return 1, None
        
            # then check if it is in the allowed range
            if 'range' in cmd_vals:
                low_limit, high_limit = [
                    float(el) for el in cmd_vals['range'].split(' ')
                ]
                
                if not low_limit <= float(val) <= high_limit:
                    print(('{val} is not within the allowed numerical range ' +
                           'for command {cmd}').format(cmd = cmd, val = val),
                          file = sys.stderr)
                    return 1, None

    else:
        # it is a read command
        cmd_type = read_char
        val = cmd_vals['format'].replace('D', '0').replace('A', '0')

    # command to the device must be in the following format
    cmd = '{char}{unit_type}{unit_addr}{cmd_type}{cmd_code}{val}'.format(
        char = cmd_char,
        unit_type = unit_type,
        unit_addr = addr,
        cmd_type = cmd_type,
        cmd_code = cmd_code,
        val = val
    )
    # append the FCS
    cmd = '{cmd}{fcs:0>2X}'.format(cmd = cmd, fcs = generate_fcs(cmd))
    return 0, cmd

###############################################################################
##################################### MISC ####################################
###############################################################################

def process_input(user_input, multi_cmds = False):
    opts, args = opt_parser.parse_args(user_input)

    port = opts.port
    device = opts.device
    address = opts.address
    interval = opts.interval
    log_file = opts.log_file
    log_dir = opts.log_dir
    continue_log = opts.continue_log
    no_log = opts.no_log
    temp_step = opts.temp_step
    start_temp = opts.start_temp
    stop_temp = opts.stop_temp
    
    if opts.port < 1:
        print('Port number must be positive!', file = sys.stderr)
        return 1, {}

    if opts.device[0] != '/':
        opts.device = '/dev/{tty}'.format(tty = opts.device)
    if not os.path.exists(opts.device):
        print('No such file {tty}! Aborting'.format(tty = opts.device),
              file = sys.stderr)
        return 1, {}
    
    if not min_unit_address <= opts.address <= max_unit_address:
        print(('Unit address must be between {min} and {max}! ' +
               'Aborting.').format(min = min_unit_address,
                                   max = max_unit_address),
              file = sys.stderr)
        return 1, {}
    opts.address = '{addr!s:0>2}'.format(addr = opts.address)

    if opts.interval < 0:
        print('Check interval cannot be negative!', file = sys.stderr)
        return 1, {}

    if opts.log_dir != '':
        if not os.path.isdir(opts.log_dir):
            os.mkdir(opts.log_dir, mode = 0o755)

    if opts.continue_log not in [None, 'last']:
        if not os.path.isfile(opts.continue_log):
            print('No such file: {log}'.format(
                log = opts.continue_log), file = sys.stderr)
            return 1, {}
            
    if opts.temp_step <= 0:
        print('Temperature step must be positive!', file = sys.stderr)
        return 1, {}

    if opts.stop_temp < opts.start_temp:
        opts.temp_step = -opts.temp_step

    user_dict = {}
    for key in vars(opts).keys():
        user_dict[key] = getattr(opts, key)
            
    if multi_cmds:
        # value is not used if multiple commands are given
        user_dict['commands'] = [el.upper() for el in args]
        
    elif len(args) > 0:
        cmd = args[0].upper()
        if 'format' not in cmds[cmd]['read']:
            # user does not provide value for this operation
            # but operation is still 'write'
            args.insert(1, '+000.000')

        if not 1 <= len(args) <= 2:
            usage()

        if len(args) == 2:
            val = args[1]
        else:
            val = ''

        user_dict['command'] = cmd
        user_dict['value'] = val
        
    else:
        user_dict['command'] = None
        user_dict['value'] = None

    return 0, user_dict

def usage():
    process_input(['--help'])
    
###############################################################################
#################################### GLOBAL ###################################
###############################################################################

allowed_actions = {
    'start': {
        'usage': '1* Daemon actions:\n    %prog start [--port] [--device]',
        'callable': start,
        'num_args': None
    },
    'stop': {
        'usage': '2    %prog stop [--port] [--device]',
        'callable': stop,
        'num_args': None
    },
    'restart': {
        'usage': '3    %prog restart [--port] [--device]',
        'callable': restart,
        'num_args': None
    },
    'reload': {
        'usage': '4    %prog reload [--port] [--device]',
        'callable': reload_config,
        'num_args': None
    },
    'single': {
        'usage': ('5* Send single command to device:\n' + \
                  '    %prog <command> [<value>] [--port] [--address]'),
        'callable': onetime_action,
        'num_args': None
    },
    'interact': {
        'usage': '6* Read commands from stdin:\n    %prog interact [--port]',
        'callable': interact,
        'num_args': None
    },
    'plot': {
        'usage': ('7* Plot reply from first command vs time and log time ' + \
                  '+ replies\n  for all given commands to file.\n' + \
                  '  By default it plots ACT_T and logs TE_V and TE_I as ' + \
                  'well:\n    %prog plot [<command> ...] [<options>]'),
        'callable': plot_realtime,
        'num_args': None
    },
    'response': {
        'usage': ('8* Plot and log Tact vs Tset for the specified ' + \
                  'range using the specified temperature step.\n' + \
                  '  Also log all specified commands:\n' + \
                  '  By default it logs time, TE_V and TE_I for all ' + \
                  'points.\n  Irrespective of given commands it logs ' + \
                  'average and sum of absolute deviation of T_ACT over ' + \
                  'the\n  sample points, as well as stabilization time:\n' + \
                  '    %prog response [<command> ...] [<options>]'),
        'callable': response_curve,
        'num_args': None
    }
}

# required configuration of serial port
serial_port = '/dev/ttyS0'
baudrate = 19200
bytesize = EIGHTBITS
parity = PARITY_NONE
stopbits = STOPBITS_ONE
xonxoff =  True
serial_timeout = 0.5

unit_type = '1'	                # must be 1 - signifies temperature controller
unit_address = 1                # default unit address
min_unit_address = 1
max_unit_address = 2
cmd_char = '!'	                # commands to the device must start with !
cmd_length = 15	                # and must be 15 bytes long excluding FCS
reply_length = 21               # device sends 21 bytes of data
discard_invalid = False         # whether or not to accept partially read reply
first_data_char = 10            # bytes 10 to 17 are the data field in the reply
last_data_char = 17
read_char = '1'	                # 1 for read commands, 2 for write commands
write_char = '2'
temp_lims = '-199.900 +199.900'	# temperature limits
res_lims = '+000.000 +499.900'	# resistance limits
cmds = {
    'ACT_T': {
	'code': '01',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'ACT_R': {
	'code': '02',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'SET_T': {
	'code': '03',
        'read': {
	    'format': '+DDD.DDD'
        },
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'SET_R': {
	'code': '04',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'TE_I': {
	'code': '05',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'TE_V': {
	'code': '06',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'LIM_I_POS': {
	'code': '07',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +005.000'
	}
    },
    'LIM_I_NEG': {
	'code': '08',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '-005.000 +000.000'
	}
    },
    'AUX_T': {
	'code': '09',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {}
    },
    'P': {
	'code': '10',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.000 +100.000',
            'alias': {
                'AUTO_S': '-002.000',
                'AUTO_D': '-001.000'
            }
	}
    },
    'I': {
	'code': '11',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+000.400 +010.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'D': {
	'code': '12',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': '+001.000 +100.000',
            'alias': {
                'OFF': '+000.000'
            }
	}
    },
    'A_T': {
	'code': '21',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'A_R': {
	'code': '22',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'B_T': {
	'code': '23',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'B_R': {
	'code': '24',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'C_T': {
	'code': '25',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'C_R': {
	'code': '26',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': res_lims
	}
    },
    'T_LIM_HIGH': {
	'code': '31',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'T_LIM_LOW': {
	'code': '32',
	'read': {
	    'format': '+DDD.DDD'
	},
	'write': {
	    'format': '+DDD.DDD',
	    'range': temp_lims
	}
    },
    'OUTPUT': {
	'code': '51',
	'read': {
	    'format': '+DDD.DDD',
            'info': """Format is: +0<AE><AS>.<TL><IS><OS>:
            AE: Autotune Error Codes:
            	1: Zero value current limit error
            	2: Current limit cannot reach SET T
            	3: Non-uniform TE I step measured
            	4: Rate sign change
            AS: Autotune Status:
            	0: Normal
            	1: Autotune
            TL: Temperature Limit or Error Limit Status:
            	0: Normal
            	1: Requires cleaning
            IS: Integrator Status:
            	0: OFF
            	1: ON
            OS: Output Status:
            	0: OFF
            	1: ON"""
		},
	'write': {
	    'format': '+DDD.DDD',
	    'alias': {
                'ON': '+000.001',
                'OFF': '+000.000'
            }
	}
    },
    'HALT': {
	'code': '52',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    },
    'LOCAL': {
	'code': '53',
        'read': {},
	'write': {
	    'format': '+DDD.DDD',
	}
    }
}

usage_msg = ('\n{actions}\n\n' + \
             'Available commands (case-insensitive):\n{cmds}').format(
                 actions = '\n'.join(
                     [el[1:] for el in sorted([ allowed_actions[key]['usage'] \
                       for key in allowed_actions.keys() ])]
                 ),
                 cmds = ', '.join(sorted(cmds.keys())))
opt_parser = OptionParser(
    usage = usage_msg,
    option_list = [
        make_option('-p', '--port',
                    type = 'int',
                    dest = 'port',
                    help = ('port number the daemon is listening on; ' + \
                            'default is {default}.').format(
                                default = socket_port),
                    metavar = 'PORT',
                    default = socket_port
        ),
        make_option('-D', '--device',
                    type = 'string',
                    dest = 'device',
                    help = ('serial device file descriptor; ' + \
                            'default is {default}.').format(
                                default = serial_port),
                    metavar = 'DEV',
                    default = serial_port
        ),
        make_option('-a', '--address',
                    type = 'int',
                    dest = 'address',
                    help = ('address of unit: {min} to {max}; ' + \
                            'default is {default}.').format(
                                min = min_unit_address,
                                max = max_unit_address,
                                default = unit_address),
                    metavar = 'UNIT_ID',
                    default = unit_address
        ),
        make_option('-i', '--interval',
                    type = 'float',
                    dest = 'interval',
                    help = ('number of seconds between data points; ' + \
                            'default is {default}.').format(
                                default = plot_interval),
                    metavar = 'SECONDS',
                    default = plot_interval
        ),
        make_option('-l', '--log-file',
                    type = 'string',
                    dest = 'log_file',
                    help = ('path to log file; ' + \
                            'default is ./<command>_unit<id>_<date_time>.log'),
                    metavar = 'FILE'
        ),
        make_option('-d', '--log-dir',
                    type = 'string',
                    dest = 'log_dir',
                    help = ('base directory for log files; ' + \
                            "default is '.'; this option is " + \
                            'ignored if --log-file is present.'),
                    metavar = 'DIR',
                    default = ''
        ),
        make_option('-c', '--continue',
                    type = 'string',
                    dest = 'continue_log',
                    help = ('continue previous log: timestamp is offset ' + \
                            'by the last timestamp in the specified file, ' + \
                            'log commands are read from the file (those ' + \
                            'specified on the command line are ignored), ' + \
                            '--log-file option is also ignored; you can ' + \
                            'give \'last\' instead of a filename, in ' + \
                            'which case the last modified file matching ' + \
                            'the pattern \'<log_dir>/*unit<unit_id>*.log\' ' + \
                            'is used.'),
                    metavar = 'FILE'
        ),
        make_option('-n', '--no-log',
                    action = 'store_true',
                    dest = 'no_log',
                    help = ('do not log; --log-file and --log-dir ' + \
                            'options are ignored if this option is present.'),
                    default = False
        ),
        make_option('-t', '--temp-step',
                    type = 'float',
                    dest = 'temp_step',
                    help = ('step in mK for reponse curve; ' + \
                            'default is {default}mK.').format(
                                default = temp_step),
                    metavar = 'TEMP',
                    default = temp_step
        ),
        make_option('-s', '--start-temp',
                    type = 'float',
                    dest = 'start_temp',
                    help = ('initial temperature in C for response curve; ' + \
                            'default is {default}C.').format(
                                default = start_temp),
                    metavar = 'TEMP',
                    default = start_temp
        ),
        make_option('-S', '--stop-temp',
                    type = 'float',
                    dest = 'stop_temp',
                    help = ('final temperature in C for response curve; ' + \
                            'default is {default}C.').format(
                                default = stop_temp),
                    metavar = 'TEMP',
                    default = stop_temp
        )
    ]
)

###############################################################################
##################################### MAIN ####################################
###############################################################################

if os.geteuid() != 0:
    print('Error: Must run as root', file = sys.stderr)
    sys.exit(1)

# must specify action
if len(sys.argv) < 2:
    usage()

action = sys.argv[1]

if action.upper() in cmds.keys():
    action = 'single'

if action not in allowed_actions.keys():
    usage()

if allowed_actions[action]['num_args'] is not None \
   and len(sys.argv) - 2 not in allowed_actions[action]['num_args']:
    usage()

status = allowed_actions[action]['callable'](sys.argv[1:])
if status is None:
    status = 0
sys.exit(status)
